# ## 1. 프로젝트 개요

### 1.1 목적

ML 추론 결과를 기반으로 한 임금 인상률 시뮬레이션 및 다차원 제약조건을 고려한 독립실행형(Standalone) 대시보드 개발

### 1.2 주요 특징

- 서버 의존성 없는 독립실행형 애플리케이션
- ML 추론 결과는 외부에서 입력받아 활용
- 로컬 저장소를 활용한 시나리오 관리
- 오프라인 환경에서도 완전한 기능 제공

### 1.3 타겟 사용자

- 인사팀 임금정책 담당자
- 경영진 및 의사결정권자
- 노사협상 실무자

## 2. 기능 요구사항

### 2.1 ML 추론 결과 관리

```
FR-001: ML 추론값 입력 및 조정
- Base-up 초기값: ML 추론 결과 표시 (예: 3.2%)
- Merit Increase 초기값: ML 추론 결과 표시 (예: 2.5%)
- Override 기능:
  * Up/Down 버튼 (±0.1% 단위)
  * 직접 입력 가능
  * 원래값 복원 버튼
- 조정 범위 제한:
  * Base-up: 3.0% ~ 3.5%
  * Merit Increase: 2.0% ~ 3.0%

FR-002: 최적 인상률 표시
- 실시간 합산값 표시 (Base-up + Merit Increase)
- AI 추천 범위 대비 현재값 표시
- 신뢰도/적정성 인디케이터
```

### 2.2 시뮬레이션 핵심 기능

```
FR-003: 직급별 Merit 가중치 조정
- 4개 직급 (Lv.1 ~ Lv.4)
- 슬라이더를 통한 가중치 조정 (0.5x ~ 1.5x)
- 실시간 계산:
  * 직급별 Merit = Merit Increase × 가중치
  * 직급별 총 인상률 = Base-up + 직급별 Merit
- 직급별 예산 영향도 표시

FR-004: 예산 제약 관리
- 총 예산 한도 설정 (기본: 500억원)
- 실시간 예산 사용률 표시
- 예산 초과 시:
  * 경고 메시지
  * 자동 조정 제안
  * 수동 조정 가이드
```

### 2.3 정액 인상 및 동종업계 비교

```
FR-005: 정액 인상 시뮬레이션
- 정액 인상 금액 설정:
  * 최소: 98만원/연
  * 기본: 100만원/연
  * 최대: 120만원/연
- 정액 vs 정률 혼합 비율 조정
- 직급별 영향도 분석

FR-006: 동종업계 비교 분석
- C사 인상률 입력 (직급별)
- 비교 우위 계산 및 시각화
- 경쟁력 지수:
  * 직급별 차이
  * 평균 차이 (+2.86%p)
- 시장 포지셔닝 분석
```

### 2.4 간접비용 자동 계산

```
FR-007: 간접비용 관리
- 퇴직급여충당금: 4.5% (수정 가능)
- 4대보험: 11.3% (수정 가능)
- 기타 간접비용 항목 추가 가능
- 총 비용 영향도:
  * 직접 인건비
  * 간접비용
  * 총 소요 예산
```

### 2.5 시나리오 관리 (로컬 저장)

```
FR-008: Quick Access 사이드바
- 시나리오 저장/불러오기:
  * 로컬 스토리지 활용
  * 파일로 내보내기/가져오기 (.json)
  * 최대 20개 시나리오 저장
- 시나리오 구성:
  * 이름 및 설명
  * 모든 파라미터 값
  * 생성/수정 일시
  * 태그 및 메모

FR-009: 시나리오 비교
- 2~4개 시나리오 동시 비교
- 주요 지표 비교 테이블
- 차이점 하이라이트
```

## 3. UI/UX 요구사항

### 3.1 인상률 조정 인터페이스

```
┌─────────────────────────────────────┐
│ Base-up        [↓] 3.2% [↑]        │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━        │
│ ML 추천: 3.2% | [원래값으로]       │
│                                     │
│ Merit Increase [↓] 2.5% [↑]        │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━        │
│ ML 추천: 2.5% | [원래값으로]       │
│                                     │
│ 총 인상률: 5.7% (적정 범위 內)     │
└─────────────────────────────────────┘
```

### 3.2 직급별 조정 카드

```
┌─────────────────────────────────────┐
│ Lv.1 (92명, 3,200억)               │
│ Merit 가중치: [━━━━●━━━] 1.1x      │
│ • Base-up: 3.2%                    │
│ • Merit: 2.75% (2.5% × 1.1)       │
│ • 총 인상률: 5.95%                 │
│ • 예산 증가: +136.7억              │
└─────────────────────────────────────┘
```

## 4. 기술 스택 (Standalone)

### 4.1 개발 옵션

#### 옵션 1: Electron + React

yaml

```yaml
framework: Electron
frontend: React + TypeScript
state: Zustand + Immer
ui: shadcn/ui + Tailwind CSS
storage: 
  - localStorage (설정)
  - IndexedDB (시나리오)
  - File System (내보내기)
charts: Recharts
build: electron-builder
```

#### 옵션 2: Tauri + React

yaml

```yaml
framework: Tauri (Rust 기반)
frontend: React + TypeScript
advantages:
  - 더 작은 번들 크기
  - 더 나은 성능
  - 네이티브 UI 옵션
storage: SQLite (로컬 DB)
```

#### 옵션 3: 순수 웹앱 (PWA)

yaml

```yaml
type: Progressive Web App
frontend: React + TypeScript
offline: Service Worker
storage: 
  - localStorage
  - IndexedDB
install: 브라우저에서 설치 가능
```

## 5. 데이터 구조

### 5.1 시뮬레이션 상태

typescript

```typescript
interface SimulationState {
  // ML 추론 결과
  mlRecommendation: {
    baseUp: number;
    meritIncrease: number;
    confidence: number;
    recommendedRange: {
      min: number;
      max: number;
    };
  };
  
  // 현재 설정값
  current: {
    baseUp: number;
    meritIncrease: number;
    isOverridden: {
      baseUp: boolean;
      meritIncrease: boolean;
    };
  };
  
  // 직급별 설정
  levels: {
    [key: string]: {
      name: string;
      employeeCount: number;
      currentBudget: number;
      meritMultiplier: number;
      calculated: {
        meritRate: number;
        totalRate: number;
        budgetIncrease: number;
        perPersonIncrease: number;
      };
    };
  };
  
  // 제약조건
  constraints: {
    budget: {
      total: number;
      limit: number;
      utilizationRate: number;
    };
    retention: {
      min: number;
      current: number;
      max: number;
    };
    indirectCosts: {
      retirement: number;
      insurance: number;
      other: number;
    };
  };
  
  // 동종업계 비교
  marketComparison: {
    competitor: string;
    byLevel: {
      [key: string]: {
        competitorRate: number;
        difference: number;
      };
    };
    averageDifference: number;
  };
}
```

### 5.2 시나리오 저장 형식

typescript

```typescript
interface SavedScenario {
  id: string;
  name: string;
  description: string;
  createdAt: string;
  updatedAt: string;
  tags: string[];
  isFavorite: boolean;
  
  snapshot: SimulationState;
  
  metadata: {
    mlVersion: string;
    appVersion: string;
    notes: string;
  };
}
```

## 6. 핵심 비즈니스 로직

### 6.1 계산 엔진

typescript

```typescript
class SalaryCalculationEngine {
  // 직급별 인상률 계산
  calculateLevelRates(
    baseUp: number,
    meritBase: number,
    multiplier: number
  ): LevelRates {
    const merit = meritBase * multiplier;
    return {
      baseUp,
      merit,
      total: baseUp + merit
    };
  }
  
  // 예산 영향도 계산
  calculateBudgetImpact(
    currentBudget: number,
    increaseRate: number,
    indirectRates: IndirectCosts
  ): BudgetImpact {
    const directIncrease = currentBudget * (increaseRate / 100);
    const retirement = directIncrease * indirectRates.retirement;
    const insurance = directIncrease * indirectRates.insurance;
    
    return {
      direct: directIncrease,
      indirect: {
        retirement,
        insurance,
        total: retirement + insurance
      },
      total: directIncrease + retirement + insurance
    };
  }
  
  // 제약조건 검증
  validateConstraints(state: SimulationState): ValidationResult {
    const violations = [];
    
    // 예산 한도 검증
    if (state.constraints.budget.utilizationRate > 100) {
      violations.push({
        type: 'BUDGET_EXCEEDED',
        severity: 'ERROR',
        message: '총 예산 한도 초과'
      });
    }
    
    // 직급 역전 검증
    const levelOrder = ['lv1', 'lv2', 'lv3', 'lv4'];
    for (let i = 0; i < levelOrder.length - 1; i++) {
      const current = state.levels[levelOrder[i]];
      const next = state.levels[levelOrder[i + 1]];
      
      if (current.calculated.totalRate < next.calculated.totalRate) {
        violations.push({
          type: 'LEVEL_INVERSION',
          severity: 'WARNING',
          message: `${current.name}이 ${next.name}보다 낮은 인상률`
        });
      }
    }
    
    return { isValid: violations.length === 0, violations };
  }
}
```

## 7. 주요 화면 흐름

### 7.1 초기 로딩

1. 앱 실행
2. 로컬 저장소에서 마지막 세션 복원
3. ML 추론값 입력 프롬프트 (선택사항)
4. 대시보드 표시

### 7.2 시뮬레이션 워크플로우

1. ML 추천값 확인
2. Up/Down 버튼으로 미세 조정
3. 직급별 가중치 설정
4. 실시간 계산 결과 확인
5. 제약조건 위반 시 조정
6. 시나리오 저장

### 7.3 시나리오 관리

1. Quick Access에서 시나리오 선택
2. 즉시 모든 값 복원
3. 조정 후 새 버전으로 저장
4. 파일로 내보내기 (공유용)

## 8. 성능 요구사항

### 8.1 응답성

- 슬라이더 조정: 즉시 반응 (<50ms)
- 계산 완료: <100ms
- 시나리오 로딩: <500ms
- 파일 저장/불러오기: <1초

### 8.2 리소스 사용

- 메모리: 최대 512MB
- CPU: 단일 코어 25% 이하
- 디스크: 설치 크기 100MB 이하

## 9. 배포 및 업데이트

### 9.1 배포 방식

- Windows: .exe 인스톨러
- macOS: .dmg 패키지
- Linux: AppImage
- 웹: PWA 설치

### 9.2 업데이트

- 자동 업데이트 확인
- 백그라운드 다운로드
- 재시작 시 적용

## 10. 확장 가능성

### 10.1 플러그인 시스템

- 커스텀 계산 공식
- 추가 차트/리포트
- 외부 데이터 연동

### 10.2 향후 기능

- 다년도 시뮬레이션
- 시나리오 공유 (클라우드)
- 협업 기능 (온라인 모드)